#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  armRightEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  armLeftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           intake1,       tmotorVex269, openLoop)
#pragma config(Motor,  port2,           rearRightMotor, tmotorVex269, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           frontRightMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           rearLeftMotor, tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port5,           frontLeftMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port6,           armRight,      tmotorVex393, openLoop, reversed, encoder, encoderPort, None, 1000)
#pragma config(Motor,  port7,           armLeft,       tmotorVex393, openLoop, encoder, encoderPort, None, 1000)
#pragma config(Motor,  port8,           armRightTop,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           armLeftTop,    tmotorVex393, openLoop)
#pragma config(Motor,  port10,          intake2,       tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
This program is designed to give new programmers beginning code that allows their robots to move from
point to point on the gameboard. The program uses three functions: moveForward, turnRight, and turnLeft
to move around the gameboard.  Each of the functions accepts two paramenters: encoderCounts and speed.
----------------------------------------------------------------------------------------------------*/

//Function to move the robot forward for a specified amount of encoder counts
//at a specified speed

void moveForward(int encoderCounts, int speed)
{
	//Clear the encoders before using them
	nMotorEncoder[rightEncoder] = 0;
	nMotorEncoder[leftEncoder]  = 0;

	//While both of the encoders are less than the specified amount
	while(nMotorEncoder[rightEncoder] < encoderCounts)
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[rightEncoder]) == abs(nMotorEncoder[leftEncoder]))
		{
			//Move the robot forward at the specified speed
			motor[rearRightMotor] = speed;
			motor[frontRightMotor] = speed;
			motor[rearLeftMotor] = speed;
			motor[frontLeftMotor] = speed;
		}

		//If the right encoder is greater than the left encoder (veering to the left)
		else if(abs(nMotorEncoder[rightEncoder]) > abs(nMotorEncoder[leftEncoder]))
		{
			//Adjust the robot slightly to the right
			motor[rearRightMotor] = speed;
			motor[frontRightMotor] = speed;
			motor[rearLeftMotor] = speed + 10;
			motor[frontLeftMotor] = speed + 10;
		}

		//If the left encoder is greater than the right encoder (veering to the right)
		else if(abs(nMotorEncoder[rightEncoder]) < abs(nMotorEncoder[leftEncoder]))
		{
			//Adjust the robot slightly to the right
			motor[rearRightMotor] = speed + 10;
			motor[frontRightMotor] = speed + 10;
			motor[rearLeftMotor] = speed;
			motor[frontLeftMotor] = speed;
		}
	}

	//Stop the robot
	motor[rearRightMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[rearLeftMotor] = 0;
	motor[frontLeftMotor] = 0;
}

void moveBackward(int encoderCounts, int speed)
{
	//Clear the encoders before using them
	nMotorEncoder[rightEncoder] = 0;
	nMotorEncoder[leftEncoder]  = 0;

	//While both of the encoders are less than the specified amount
	while(nMotorEncoder[rightEncoder] > -encoderCounts)
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[rightEncoder]) == abs(nMotorEncoder[leftEncoder]))
		{
			//Move the robot forward at the specified speed
			motor[rearRightMotor] = -speed;
			motor[frontRightMotor] = -speed;
			motor[rearLeftMotor] = -speed;
			motor[frontLeftMotor] = -speed;
		}

		//If the right encoder is greater than the left encoder (veering to the left)
		else if(abs(nMotorEncoder[rightEncoder]) < abs(nMotorEncoder[leftEncoder]))
		{
			//Adjust the robot slightly to the right
			motor[rearRightMotor] = -speed;
			motor[frontRightMotor] = -speed;
			motor[rearLeftMotor] = -speed - 10;
			motor[frontLeftMotor] = -speed - 10;
		}

		//If the left encoder is greater than the right encoder (veering to the right)
		else if(abs(nMotorEncoder[rightEncoder]) > abs(nMotorEncoder[leftEncoder]))
		{
			//Adjust the robot slightly to the right
			motor[rearRightMotor] = -speed - 10;
			motor[frontRightMotor] = -speed - 10;
			motor[rearLeftMotor] = -speed;
			motor[frontLeftMotor] = -speed;
		}
	}

	//Stop the robot
	motor[rearRightMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[rearLeftMotor] = 0;
	motor[frontLeftMotor] = 0;
}

//Turn the robot left for the specified encoder counts
//at a specified speed
void turnLeft(int encoderCounts, int speed)
{
	//Clear the encoders before using them
	nMotorEncoder[rightEncoder] = 0;
	nMotorEncoder[leftEncoder]  = 0;

	//While the absolute value of the right motor's encoder is less
	//than the specified amount
	while(abs(nMotorEncoder[rightEncoder]) < encoderCounts)
	{
		//Turn the robot to the left at the specified speed
		motor[rearRightMotor] = speed;
		motor[frontRightMotor] = speed;
		motor[rearLeftMotor] = -speed;
		motor[frontLeftMotor] = -speed;
	}

	//Stop the robot
	motor[rearRightMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[rearLeftMotor] = 0;
	motor[frontLeftMotor] = 0;
}

//Turn the robot left for the specified encoder counts
//at a specified speed
void turnRight(int encoderCounts, int speed)
{
	//Clear the encoders
	nMotorEncoder[rightEncoder] = 0;
	nMotorEncoder[leftEncoder]  = 0;

	//While the absolute value of the left motor's encoder is less
	//than the specified amount
	while(abs(nMotorEncoder[leftEncoder]) < encoderCounts)
	{
		//Turn the robot to the right at the specified speed
		motor[rearRightMotor] = -speed;
		motor[frontRightMotor] = -speed;
		motor[rearLeftMotor] = speed;
		motor[frontLeftMotor] = speed;
	}

	//Stop the robot
	motor[rearRightMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[rearLeftMotor] = 0;
	motor[frontLeftMotor] = 0;
}
void movebottom(int time, int speed)
{
	motor[ArmRight] = speed;
	motor[ArmLeft] = speed;
	wait1Msec(time);
	motor[ArmRight] = 0;
	motor[ArmLeft] = 0;
}
void movetop(int time, int speed)
{
	motor[ArmRightTop] = speed;
	motor[ArmLeftTop] = speed;
	wait1Msec(time);
	motor[ArmRightTop] = 0;
	motor[ArmLeftTop] = 0;
}
void moveintake(int time, int speed)
{
	motor[intake1] = speed;
	motor[intake2] = speed;
	wait1Msec(time);
	motor[intake1] = 0;
	motor[intake2] = 0;
}

task bottomArmLift
{nMotorEncoder[armRightEncoder] = 0;
	nMotorEncoder[armLeftEncoder]  = 0;
	motor[armRight] = speed;
	motor[armLeft] = speed;
	while(nMotorEncoder[armRightEncoder] < encoderCounts)
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[armRightEncoder]) == abs(nMotorEncoder[armLeftEncoder]))
		{
			//Move the robot forward at the specified speed
			motor[ArmRight] = speed;
			motor[ArmLeft] = speed;
		}

		//If the right encoder is greater than the left encoder (veering to the left)
		else if(abs(nMotorEncoder[armRightEncoder]) > abs(nMotorEncoder[armLeftEncoder]))
		{
			//Adjust the robot slightly to the right
			motor[ArmRight] = speed;
			motor[ArmLeft] = speed + 10;
		}

		//If the left encoder is greater than the right encoder (veering to the right)
		else if(abs(nMotorEncoder[armRightEncoder]) < abs(nMotorEncoder[armLeftEncoder]))
		{
			//Adjust the robot slightly to the right
			motor[ArmRight] = speed + 10;
			motor[ArmLeft] = speed;
		}
	}
	/*
	intake1,       tmotorVex269, openLoop)
rearRightMotor, tmotorVex269, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
frontRightMotor, tmotorVex393, openLoop, reversed)
rearLeftMotor, tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
frontLeftMotor, tmotorVex393, openLoop)
ArmRight
ArmRightTop
ArmLeftTop
intake2
*/
}

task bottomArmLower
{
	nMotorEncoder[armRightEncoder] = 0;
	nMotorEncoder[armLeftEncoder]  = 0;

	while(nMotorEncoder[armRightEncoder] > encoderCounts)
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[armRightEncoder]) == abs(nMotorEncoder[armLeftEncoder]))
		{
			//Move the robot forward at the specified speed
			motor[ArmRight] = -speed;
			motor[ArmLeft] = -speed;
		}

		//If the right encoder is greater than the left encoder (veering to the left)
		else if(abs(nMotorEncoder[armRightEncoder]) < abs(nMotorEncoder[armLeftEncoder]))
		{
			//Adjust the robot slightly to the right
			motor[ArmRight] = -speed;
			motor[ArmLeft] = -speed - 10;
		}

		//If the left encoder is greater than the right encoder (veering to the right)
		else if(abs(nMotorEncoder[armRightEncoder]) > abs(nMotorEncoder[armLeftEncoder]))
		{
			//Adjust the robot slightly to the right
			motor[ArmRight] = -speed - 10;
			motor[ArmLeft] = -speed;
		}
	}
}


task upperArmLift
{
	motor[armRightTop] = speed;
	motor[armLeftTop] = speed;
	wait1Msec(time);
}

task upperArmLower
{
	motor[armRightTop] = -speed;
	motor[armLeftTop] = -speed;
	wait1Msec(time);
}

task intakeLift
{
	motor[intake1] = speed;
	motor[intake2] = speed;
	wait1Msec(time);
}

task intakeLower
{
	motor[intake1] = -speed;
	motor[intake2] = -speed;
	wait1Msec(time);
}

task main()
{
	//Move the robot forward for 1000 encoder counts
	//at a speed of 50, then wait for half of a second
	//moveForward(1000, 100);
	wait1Msec(500);

	//Turn the robot to the right for 480 encoder counts
	//at a speed of 25, then wait for half of a second
//	moveForward(1355, -100);
	wait1Msec(500);
	movebottom(2000, 100);
	wait1Msec(500);
	moveintake(3000, -100);
	//moveintake(3000,100);

	//Turn the robot to the left for 480 encoder counts
	//at a speed of 25, then wait for half of a second
//	turnLeft(1000, 100);
	wait1Msec(500);
}
