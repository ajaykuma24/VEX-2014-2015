#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  Rightlim,       sensorTouch)
#pragma config(Sensor, dgtl2,  Leftlim,        sensorTouch)
#pragma config(Sensor, dgtl3,  Toplim,         sensorTouch)
#pragma config(Sensor, I2C_1,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  armrearRightMotor, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  armLeftEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           intake1,       tmotorVex269, openLoop)
#pragma config(Motor,  port2,           rearRightMotor, tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           frontRightMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           rearLeftMotor, tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port5,           frontLeftMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port6,           ArmRight,      tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port7,           ArmLeft,       tmotorVex393, openLoop, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port8,           ArmRightTop,   tmotorVex393, openLoop)
#pragma config(Motor,  port9,           ArmLeftTop,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          intake2,       tmotorVex269, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
//#pragma autonomousDuration(20)
//#pragma userControlDuration(120)


#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int G_time=0;
int G_speed=0;
int G_encodercounts = 0;
void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
  	//Clear the encoders before using them
		nMotorEncoder[rearLeftMotor] = 0;
		nMotorEncoder[rearRightMotor] = 0;
		nMotorEncoder[ArmLeft] = 0;
		nMotorEncoder[ArmRight] = 0;


	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
void moveForward(int encoderCounts, int speed)
{
	//Clear the encoders before using them
	nMotorEncoder[rearRightMotor] = 0;
	nMotorEncoder[rearLeftMotor]  = 0;

	//While both of the encoders are less than the specified amount
	while(nMotorEncoder[rearRightMotor] < encoderCounts)
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[rearRightMotor]) == abs(nMotorEncoder[rearLeftMotor]))
		{
			//Move the robot forward at the specified speed
			motor[rearRightMotor] = speed;
			motor[frontRightMotor] = speed;
			motor[rearLeftMotor] = speed;
			motor[frontLeftMotor] = speed;
		}

		//If the right encoder is greater than the left encoder (veering to the left)
		else if(abs(nMotorEncoder[rearRightMotor]) > abs(nMotorEncoder[rearLeftMotor]))
		{
			//Adjust the robot slightly to the right
			motor[rearRightMotor] = speed;
			motor[frontRightMotor] = speed;
			motor[rearLeftMotor] = speed + 10;
			motor[frontLeftMotor] = speed + 10;
		}

		//If the left encoder is greater than the right encoder (veering to the right)
		else if(abs(nMotorEncoder[rearRightMotor]) < abs(nMotorEncoder[rearLeftMotor]))
		{
			//Adjust the robot slightly to the right
			motor[rearRightMotor] = speed + 10;
			motor[frontRightMotor] = speed + 10;
			motor[rearLeftMotor] = speed;
			motor[frontLeftMotor] = speed;
		}
	}

	//Stop the robot
	motor[rearRightMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[rearLeftMotor] = 0;
	motor[frontLeftMotor] = 0;
}

void moveBackward(int encoderCounts, int speed)
{
	//Clear the encoders before using them
	nMotorEncoder[rearRightMotor] = 0;
	nMotorEncoder[rearLeftMotor]  = 0;

	//While both of the encoders are less than the specified amount
	while(nMotorEncoder[rearRightMotor] > -encoderCounts)
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[rearRightMotor]) == abs(nMotorEncoder[rearLeftMotor]))
		{
			//Move the robot forward at the specified speed
			motor[rearRightMotor] = -speed;
			motor[frontRightMotor] = -speed;
			motor[rearLeftMotor] = -speed;
			motor[frontLeftMotor] = -speed;
		}

		//If the right encoder is greater than the left encoder (veering to the left)
		else if(abs(nMotorEncoder[rearRightMotor]) < abs(nMotorEncoder[rearLeftMotor]))
		{
			//Adjust the robot slightly to the right
			motor[rearRightMotor] = -speed;
			motor[frontRightMotor] = -speed;
			motor[rearLeftMotor] = -speed - 10;
			motor[frontLeftMotor] = -speed - 10;
		}

		//If the left encoder is greater than the right encoder (veering to the right)
		else if(abs(nMotorEncoder[rearRightMotor]) > abs(nMotorEncoder[rearLeftMotor]))
		{
			//Adjust the robot slightly to the right
			motor[rearRightMotor] = -speed - 10;
			motor[frontRightMotor] = -speed - 10;
			motor[rearLeftMotor] = -speed;
			motor[frontLeftMotor] = -speed;
		}
	}

	//Stop the robot
	motor[rearRightMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[rearLeftMotor] = 0;
	motor[frontLeftMotor] = 0;
}

//Turn the robot left for the specified encoder counts
//at a specified speed
void turnLeft(int encoderCounts, int speed)
{
	//Clear the encoders before using them
	nMotorEncoder[rearRightMotor] = 0;
	nMotorEncoder[rearLeftMotor]  = 0;

	//While the absolute value of the right motor's encoder is less
	//than the specified amount
	while(abs(nMotorEncoder[rearRightMotor]) < encoderCounts)
	{
		//Turn the robot to the left at the specified speed
		motor[rearRightMotor] = speed;
		motor[frontRightMotor] = speed;
		motor[rearLeftMotor] = -speed;
		motor[frontLeftMotor] = -speed;
	}

	//Stop the robot
	motor[rearRightMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[rearLeftMotor] = 0;
	motor[frontLeftMotor] = 0;
}

//Turn the robot left for the specified encoder counts
//at a specified speed
void turnRight(int encoderCounts, int speed)
{
	//Clear the encoders
	nMotorEncoder[rearRightMotor] = 0;
	nMotorEncoder[rearLeftMotor]  = 0;

	//While the absolute value of the left motor's encoder is less
	//than the specified amount
	while(abs(nMotorEncoder[rearLeftMotor]) < encoderCounts)
	{
		//Turn the robot to the right at the specified speed
		motor[rearRightMotor] = -speed;
		motor[frontRightMotor] = -speed;
		motor[rearLeftMotor] = speed;
		motor[frontLeftMotor] = speed;
	}

	//Stop the robot
	motor[rearRightMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[rearLeftMotor] = 0;
	motor[frontLeftMotor] = 0;
}


task bottomArmLift
{nMotorEncoder[ArmRight] = 0;
	nMotorEncoder[ArmLeft]  = 0;
	motor[ArmRight] = G_speed;
	motor[ArmLeft] = G_speed;
	while(nMotorEncoder[ArmRight] < G_encodercounts&&!SensorValue[Rightlim]&&!SensorValue[Leftlim])
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[ArmRight]) == abs(nMotorEncoder[ArmLeft]))
		{
			//Move the robot forward at the specified speed
			motor[ArmRight] = G_speed;
			motor[ArmLeft] = G_speed;
		}

		//If the right encoder is greater than the left encoder (veering to the left)
		else if(abs(nMotorEncoder[ArmRight]) > abs(nMotorEncoder[ArmLeft]))
		{
			//Adjust the robot slightly to the right
			motor[ArmRight] = G_speed;
			motor[ArmLeft] = G_speed + 10;
		}

		//If the left encoder is greater than the right encoder (veering to the right)
		else if(abs(nMotorEncoder[ArmRight]) < abs(nMotorEncoder[ArmLeft]))
		{
			//Adjust the robot slightly to the right
			motor[ArmRight] = G_speed + 10;
			motor[ArmLeft] = G_speed;
		}
	}
	motor[ArmRight] = 0;
	motor[ArmLeft] = 0;

}

task bottomArmLower
{
	nMotorEncoder[ArmRight] = 0;
	nMotorEncoder[ArmLeft]  = 0;

	while(nMotorEncoder[ArmRight] > G_encodercounts)
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[ArmRight]) == abs(nMotorEncoder[ArmLeft]))
		{
			//Move the robot forward at the specified speed
			motor[ArmRight] = -G_speed;
			motor[ArmLeft] = -G_speed;
		}

		//If the right encoder is greater than the left encoder (veering to the left)
		else if(abs(nMotorEncoder[ArmRight]) < abs(nMotorEncoder[ArmLeft]))
		{
			//Adjust the robot slightly to the right
			motor[ArmRight] = -G_speed;
			motor[ArmLeft] = -G_speed - 10;
		}

		//If the left encoder is greater than the right encoder (veering to the right)
		else if(abs(nMotorEncoder[ArmRight]) > abs(nMotorEncoder[ArmLeft]))
		{
			//Adjust the robot slightly to the right
			motor[ArmRight] = -G_speed - 10;
			motor[ArmLeft] = -G_speed;
		}
	}
	motor[ArmRight] = 0;
	motor[ArmLeft] = 0;
}


task upperArmLift
{
	motor[ArmRightTop] = G_speed;
	motor[ArmLeftTop] = G_speed;
	wait1Msec(G_time);
	motor[ArmRightTop] = 0;
	motor[ArmLeftTop] = 0;
}
task upperArmLimit
{
	while(!SensorValue[Toplim])
	{
	motor[ArmRightTop] = G_speed;
	motor[ArmLeftTop] = G_speed;
	}
	motor[ArmRightTop] = 0;
	motor[ArmLeftTop] = 0;

}

task upperArmLower
{
	motor[ArmRightTop] = -G_speed;
	motor[ArmLeftTop] = -G_speed;
	wait1Msec(G_time);
	motor[ArmRightTop] = 0;
	motor[ArmLeftTop] = 0;

}

task intakeLift
{
	motor[intake1] = G_speed;
	motor[intake2] = G_speed;


	wait1Msec(G_time);
	motor[intake1] = 0;
	motor[intake2] = 0;
}

task intakeLower
{
	motor[intake1] = -G_speed;
	motor[intake2] = -G_speed;
	wait1Msec(G_time);
	motor[intake1] = 0;
	motor[intake2] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................



	//Move the robot forward for 1000 encoder counts
	//at a speed of 50, then wait for half of a second
G_time=1000;
G_speed=100;
	moveBackward(1000, 100);
	StartTask(upperArmLift);
	wait1Msec(2200);
	G_time=3500;
	StartTask(intakeLower);
	wait1Msec(3000);
	StartTask(intakeLift);
	wait1Msec(3000);
//	StartTask(upperArmLimit);
//	wait1Msec(2000);
	G_time=2000;
	//StartTask(intakeLower);

//	StartTask(intakeLower);
	//StopTask(intakeLower);
	//moveintake(3000,100);

	//Turn the robot to the left for 480 encoder counts
	//at a speed of 25, then wait for half of a second
//	turnLeft(1000, 100);
	wait1Msec(10000);




}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop
int thresh = 25;
	while (true)
	{
	  // This is the main execution loop for the user control program. Each time through the loop
	  // your program should update motor + servo values based on feedback from the joysticks.

	  // .....................................................................................


		while(1==1)
		{
				if(abs(vexRT[Ch3])>thresh)
				{
						motor[frontLeftMotor] = vexRT[Ch3];
						motor[rearLeftMotor] =  vexRT[Ch3];
				}
				else if(abs(vexRT[Ch3])<=thresh)
				{
						motor[frontLeftMotor] = 0;
						motor[rearLeftMotor] =  0;
				}
				if(abs(vexRT[Ch2])>thresh)
				{
						motor[frontRightMotor] = vexRT[Ch2];
						motor[rearRightMotor] =  vexRT[Ch2];
				}
				else if(abs(vexRT[Ch2])<=thresh)
				{
						motor[frontRightMotor] = 0;
						motor[rearRightMotor] =  0;
				}
				if((vexRT [Ch2Xmtr2]) > thresh && !SensorValue[Rightlim] && !SensorValue[Leftlim])
				{
						motor[ArmRight] = vexRT[Ch2Xmtr2];
						motor[ArmLeft] = vexRT[Ch2Xmtr2];
				}
				else if((vexRT [Ch2Xmtr2]) > thresh && !SensorValue[Rightlim] && SensorValue[Leftlim])
				{
						motor[ArmRight] = vexRT[Ch2Xmtr2];
						motor[ArmLeft] = 0;
				}
				else if((vexRT [Ch2Xmtr2]) > thresh && SensorValue[Rightlim] && !SensorValue[Leftlim])
				{
						motor[ArmRight] = 0;
						motor[ArmLeft] = vexRT[Ch2Xmtr2];
				}
				else if((vexRT [Ch2Xmtr2]) < -thresh)
				{
							motor[ArmRight] = vexRT[Ch2Xmtr2];
							motor[ArmLeft] = vexRT[Ch2Xmtr2];
				}
				else if((vexRT[Ch2Xmtr2]) <=thresh||(SensorValue[Rightlim]&&SensorValue[Leftlim]))
				{
						motor[ArmRight] = 0;
						motor[ArmLeft] = 0;
				}
				if(vexRT [Ch3Xmtr2] > thresh&&SensorValue[Toplim]==0)
				{
						motor[ArmRightTop] = vexRT[Ch3Xmtr2];
						motor[ArmLeftTop] = vexRT[Ch3Xmtr2];
				}
				else if(vexRT[Ch3Xmtr2] < -thresh)
				{
						motor[ArmRightTop] = vexRT[Ch3Xmtr2];
						motor[ArmLeftTop] = vexRT[Ch3Xmtr2];
				}
				else if(abs(vexRT[Ch3Xmtr2]) <=thresh||SensorValue[Toplim]==1)
				{
						motor[ArmRightTop] = 0;
						motor[ArmLeftTop] = 0;
				}
				if(vexRT[Btn5U])
				{
						motor[intake1] = 100;
						motor[intake2] = 100;
				}
				else if(vexRT[Btn5D])
				{
						motor[intake1] = -100;
						motor[intake2] = -100;
				}
				else
				{
						motor[intake1] = 0;
						motor[intake2] = 0;
				}

}
	  // .....................................................................................

	}
}
